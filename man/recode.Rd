% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/recode.R
\name{recode}
\alias{binary_recode}
\alias{recode}
\title{Flexible}
\usage{
recode(x, ..., .default = NULL, .na = NA, factor = FALSE)

binary_recode(x, one, .na = NA)
}
\arguments{
\item{x}{a vector}

\item{...}{a sequence of arguments where the name is the replacement and the
value are the elements to be replaced.  This is opposite the behavior of
\code{dplyr::recode} and \code{plyr::revalue}.}

\item{.default}{the value is assigned to all elements of \code{x} not 
matching any of the replacement values in \code{...} (i.e. a catch-all 
replacement value for anything not explicitly mapped).}

\item{.na}{all values in \code{.na} will be assigned NA.}

\item{factor}{If TRUE, returned the recoded version of \code{x} as a factor.
Defaults to FALSE, in which all non-NA elements are forced to character.}

\item{one}{for \code{binary_recode}, all elements of \code{x} in \code{one}
will be assigned 1, anything in \code{.na} will be assigned NA, and anything
left over will be assigned 0.}
}
\value{
a vector of the same length as \code{x} in which all substitutions
specified in \code{...} (or \code{one} in \code{binary_recode}) are made.
}
\description{
Collapse multiple original values of a vector into single new values.  An
alternative to nested \code{ifelse} statements, \code{dplyr::recode},
\code{plyr::revalue}, etc.
}
\examples{
s <- c("a", "b", "c", "d", "e", "f", NA)
recode(s, `1` = c("a", "b"), .default = 0)
recode(s, `1` = c("a", "b"), .na = c(NA, "d", "e"))
recode(s, `1` = c("a", "b"))
recode(s, `1` = c("a", "b"), factor = TRUE)
binary_recode(s, one = c("a", "b"))

}

